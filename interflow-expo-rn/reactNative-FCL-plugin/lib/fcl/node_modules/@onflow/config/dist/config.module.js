import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _toArray from '@babel/runtime/helpers/toArray';
import _typeof from '@babel/runtime/helpers/typeof';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { SUBSCRIBE, UNSUBSCRIBE, spawn, send, subscriber } from '@onflow/util-actor';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';

/**
 * Asserts fact is true, otherwise throw an error with invariant message
 * @param {boolean} fact
 * @param {string} msg
 * @param {Array} rest
 * @returns {void}
 */

function invariant$1(fact, msg) {
  if (!fact) {
    var _console;

    var error = new Error("INVARIANT ".concat(msg));
    error.stack = error.stack.split("\n").filter(function (d) {
      return !/at invariant/.test(d);
    }).join("\n");

    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }

    (_console = console).error.apply(_console, ["\n\n---\n\n", error, "\n\n"].concat(rest, ["\n\n---\n\n"]));

    throw error;
  }
}

var pipe$1 = function pipe() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function (v) {
    return funcs.reduce(function (res, func) {
      return func(res);
    }, v);
  };
};
/***
 * Merge multiple functions returning objects into one object.
 * @param {...function(*): Object} funcs
 * @return {Object}
 */


var mergePipe$1 = function mergePipe() {
  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    funcs[_key2] = arguments[_key2];
  }

  return function (v) {
    return funcs.reduce(function (res, func) {
      return _objectSpread(_objectSpread({}, res), func(v));
    }, {});
  };
};
/**
 * Object check.
 * @param value
 * @returns {boolean}
 */


var isObject$1 = function isObject(value) {
  return value && _typeof(value) === "object" && !Array.isArray(value);
};
/**
 * Deep merge multiple objects.
 * @param {Object} target
 * @param {...Object[]} sources
 * @returns {Object}
 */


var mergeDeep$1 = function mergeDeep(target) {
  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    sources[_key3 - 1] = arguments[_key3];
  }

  if (!sources.length) return target;
  var source = sources.shift();

  if (isObject$1(target) && isObject$1(source)) {
    for (var key in source) {
      if (isObject$1(source[key])) {
        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, _defineProperty({}, key, source[key]));
      }
    }
  }

  return mergeDeep.apply(void 0, [target].concat(sources));
};
/**
 * Deep merge multiple Flow JSON.
 * @param {Object|Object[]} value
 * @returns {Object}
 */


var mergeFlowJSONs$1 = function mergeFlowJSONs(value) {
  return Array.isArray(value) ? mergeDeep$1.apply(void 0, [{}].concat(_toConsumableArray(value))) : value;
};
/**
 * Filter out contracts section of flow.json.
 * @param {Object|Object[]} obj
 * @returns {Object}
 */


var filterContracts$1 = function filterContracts(obj) {
  return obj.contracts ? obj.contracts : {};
};
/**
 * Gathers contract addresses by network
 * @param {string} network emulator, testnet, mainnet
 * @returns {Object} { "HelloWorld": "0x123" }
 */


var mapContractAliasesToNetworkAddress$1 = function mapContractAliasesToNetworkAddress(network) {
  return function (contracts) {
    return Object.entries(contracts).reduce(function (c, _ref) {
      var _value$aliases;

      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      var networkContractAlias = value === null || value === void 0 ? void 0 : (_value$aliases = value.aliases) === null || _value$aliases === void 0 ? void 0 : _value$aliases[network];

      if (networkContractAlias) {
        c[key] = networkContractAlias;
      }

      return c;
    }, {});
  };
};

var mapDeploymentsToNetworkAddress$1 = function mapDeploymentsToNetworkAddress(network) {
  return function (_ref3) {
    var _ref3$deployments = _ref3.deployments,
        deployments = _ref3$deployments === void 0 ? {} : _ref3$deployments,
        _ref3$accounts = _ref3.accounts,
        accounts = _ref3$accounts === void 0 ? {} : _ref3$accounts;
    var networkDeployment = deployments === null || deployments === void 0 ? void 0 : deployments[network];
    if (!networkDeployment) return {};
    return Object.entries(networkDeployment).reduce(function (c, _ref4) {
      var _accounts$key;

      var _ref5 = _slicedToArray(_ref4, 2),
          key = _ref5[0],
          value = _ref5[1]; // Resolve account address


      var accountAddress = (_accounts$key = accounts[key]) === null || _accounts$key === void 0 ? void 0 : _accounts$key.address;
      if (!accountAddress) return c; // Create an object assigning the address to the contract name.

      return value.reduce(function (c, contract) {
        return _objectSpread(_objectSpread({}, c), {}, _defineProperty({}, contract, accountAddress));
      }, {});
    }, {});
  };
};
/**
 * Take in flow.json files and return contract to address mapping by network
 * @param {Object|Object[]} jsons
 * @param {string} network emulator, testnet, mainnet
 * @returns {Object} { "HelloWorld": "0x123" }
 */


var getContracts$1 = function getContracts(jsons, network) {
  return pipe$1(mergeFlowJSONs$1, mergePipe$1(mapDeploymentsToNetworkAddress$1(network), pipe$1(filterContracts$1, mapContractAliasesToNetworkAddress$1(network))))(jsons);
};
/**
 * Checks flow.json file for private keys
 * @param {Object} flowJSON
 * @returns {boolean}
 */


var hasPrivateKeys$1 = function hasPrivateKeys(flowJSON) {
  return Object.entries(flowJSON === null || flowJSON === void 0 ? void 0 : flowJSON.accounts).reduce(function (hasPrivateKey, _ref6) {
    var _value$key;

    var _ref7 = _slicedToArray(_ref6, 2);

    _ref7[0];
    var value = _ref7[1];
    if (hasPrivateKey) return true;
    return (value === null || value === void 0 ? void 0 : value.hasOwnProperty("key")) && !(value !== null && value !== void 0 && (_value$key = value.key) !== null && _value$key !== void 0 && _value$key.startsWith("$"));
  }, false);
};
/**
 * Take in flow.json or array of flow.json files and checks for private keys
 * @param {Object|Object[]} value
 * @returns {boolean}
 */


var anyHasPrivateKeys$1 = function anyHasPrivateKeys(value) {
  if (isObject$1(value)) return hasPrivateKeys$1(value);
  return value.some(hasPrivateKeys$1);
};
/**
 * Format network to always be 'emulator', 'testnet', or 'mainnet'
 * @param {string} network 'local', 'emulator', 'testnet', 'mainnet'
 * @returns {string} 'emulator', 'testnet', 'mainnet'
 */


var cleanNetwork$1 = function cleanNetwork(network) {
  return (network === null || network === void 0 ? void 0 : network.toLowerCase()) === "local" ? "emulator" : network === null || network === void 0 ? void 0 : network.toLowerCase();
};

var _HANDLERS$1;

var NAME$1 = "config";
var PUT$1 = "PUT_CONFIG";
var GET$1 = "GET_CONFIG";
var GET_ALL$1 = "GET_ALL_CONFIG";
var UPDATE$1 = "UPDATE_CONFIG";
var DELETE$1 = "DELETE_CONFIG";
var CLEAR$1 = "CLEAR_CONFIG";
var WHERE$1 = "WHERE_CONFIG";
var UPDATED$1 = "CONFIG/UPDATED";

var identity$1 = function identity(v) {
  return v;
};

var HANDLERS$1 = (_HANDLERS$1 = {}, _defineProperty(_HANDLERS$1, PUT$1, function (ctx, _letter, _ref) {
  var key = _ref.key,
      value = _ref.value;
  if (key == null) throw new Error("Missing 'key' for config/put.");
  ctx.put(key, value);
  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS$1, GET$1, function (ctx, letter, _ref2) {
  var key = _ref2.key,
      fallback = _ref2.fallback;
  if (key == null) throw new Error("Missing 'key' for config/get");
  letter.reply(ctx.get(key, fallback));
}), _defineProperty(_HANDLERS$1, GET_ALL$1, function (ctx, letter) {
  letter.reply(_objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS$1, UPDATE$1, function (ctx, letter, _ref3) {
  var key = _ref3.key,
      fn = _ref3.fn;
  if (key == null) throw new Error("Missing 'key' for config/update");
  ctx.update(key, fn || identity$1);
  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS$1, DELETE$1, function (ctx, letter, _ref4) {
  var key = _ref4.key;
  if (key == null) throw new Error("Missing 'key' for config/delete");
  ctx["delete"](key);
  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS$1, CLEAR$1, function (ctx, letter) {
  var keys = Object.keys(ctx.all());

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    ctx["delete"](key);
  }

  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS$1, WHERE$1, function (ctx, letter, _ref5) {
  var pattern = _ref5.pattern;
  if (pattern == null) throw new Error("Missing 'pattern' for config/where");
  letter.reply(ctx.where(pattern));
}), _defineProperty(_HANDLERS$1, SUBSCRIBE, function (ctx, letter) {
  ctx.subscribe(letter.from);
  ctx.send(letter.from, UPDATED$1, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS$1, UNSUBSCRIBE, function (ctx, letter) {
  ctx.unsubscribe(letter.from);
}), _HANDLERS$1);
spawn(HANDLERS$1, NAME$1);

function put$1(key, value) {
  send(NAME$1, PUT$1, {
    key: key,
    value: value
  });
  return config$1();
}

function get$1(key, fallback) {
  return send(NAME$1, GET$1, {
    key: key,
    fallback: fallback
  }, {
    expectReply: true,
    timeout: 10
  });
}

function first$1() {
  return _first$1.apply(this, arguments);
}

function _first$1() {
  _first$1 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var wants,
        fallback,
        _wants,
        head,
        rest,
        ret,
        _args2 = arguments;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            wants = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [];
            fallback = _args2.length > 1 ? _args2[1] : undefined;

            if (wants.length) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", fallback);

          case 4:
            _wants = _toArray(wants), head = _wants[0], rest = _wants.slice(1);
            _context2.next = 7;
            return get$1(head);

          case 7:
            ret = _context2.sent;

            if (!(ret == null)) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt("return", first$1(rest, fallback));

          case 10:
            return _context2.abrupt("return", ret);

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _first$1.apply(this, arguments);
}

function all$1() {
  return send(NAME$1, GET_ALL$1, null, {
    expectReply: true,
    timeout: 10
  });
}

function update$1(key) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;
  send(NAME$1, UPDATE$1, {
    key: key,
    fn: fn
  });
  return config$1();
}

function _delete$1(key) {
  send(NAME$1, DELETE$1, {
    key: key
  });
  return config$1();
}

function where$1(pattern) {
  return send(NAME$1, WHERE$1, {
    pattern: pattern
  }, {
    expectReply: true,
    timeout: 10
  });
}

function subscribe$1(callback) {
  return subscriber(NAME$1, function () {
    return spawn(HANDLERS$1, NAME$1);
  }, callback);
}

function clearConfig$1() {
  return send(NAME$1, CLEAR$1);
}

function resetConfig$1(oldConfig) {
  return clearConfig$1().then(config$1(oldConfig));
}
/**
 * Takes in flow.json or array of flow.json files and creates contract placeholders
 * @param {Object|Object[]} data
 * @returns {void}
 */


function load$1(_x) {
  return _load$1.apply(this, arguments);
}
/**
 * Takes an object of config keys and returns an object with config methods
 *
 * @param {Object} values
 * @returns {Object} config
 * @returns {Function} config.put
 * @returns {Function} config.get
 * @returns {Function} config.all
 * @returns {Function} config.first
 * @returns {Function} config.update
 * @returns {Function} config.delete
 * @returns {Function} config.where
 * @returns {Function} config.subscribe
 * @returns {Function} config.overload
 * @returns {Function} config.load
 *
 * @example
 * import {config} from "@onflow/fcl"
 * config({ "flow.network": "testnet" })
 *
 */


function _load$1() {
  _load$1 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(data) {
    var network, cleanedNetwork, flowJSON, isEmulator, _i2, _Object$entries, _Object$entries$_i, key, value, contractConfigKey, existingContractConfigKey, systemContractConfigKey, systemExistingContractConfigKeyValue;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return get$1("flow.network");

          case 2:
            network = _context3.sent;
            cleanedNetwork = cleanNetwork$1(network);
            flowJSON = data.flowJSON;
            invariant$1(Boolean(flowJSON), "config.load -- 'flowJSON' must be defined");
            invariant$1(cleanedNetwork, "Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl");

            if (!anyHasPrivateKeys$1(flowJSON)) {
              _context3.next = 12;
              break;
            }

            isEmulator = cleanedNetwork === "emulator";
            log({
              title: "Private Keys Detected",
              message: "Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security",
              level: isEmulator ? LEVELS.warn : LEVELS.error
            });

            if (isEmulator) {
              _context3.next = 12;
              break;
            }

            return _context3.abrupt("return");

          case 12:
            _i2 = 0, _Object$entries = Object.entries(getContracts$1(flowJSON, cleanedNetwork));

          case 13:
            if (!(_i2 < _Object$entries.length)) {
              _context3.next = 28;
              break;
            }

            _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
            contractConfigKey = "0x".concat(key);
            _context3.next = 18;
            return get$1(contractConfigKey);

          case 18:
            existingContractConfigKey = _context3.sent;

            if (existingContractConfigKey && existingContractConfigKey !== value) {
              log({
                title: "Contract Placeholder Conflict Detected",
                message: "A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.",
                level: LEVELS.warn
              });
            } else {
              put$1(contractConfigKey, value);
            }

            systemContractConfigKey = "system.contracts.".concat(key);
            _context3.next = 23;
            return get$1(systemContractConfigKey);

          case 23:
            systemExistingContractConfigKeyValue = _context3.sent;

            if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {
              log({
                title: "Contract Placeholder Conflict Detected",
                message: "A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.",
                level: LEVELS.warn
              });
            } else {
              put$1(systemContractConfigKey, value);
            }

          case 25:
            _i2++;
            _context3.next = 13;
            break;

          case 28:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _load$1.apply(this, arguments);
}

function config$1(values) {
  if (values != null && _typeof(values) === "object") {
    Object.keys(values).map(function (d) {
      return put$1(d, values[d]);
    });
  }

  return {
    put: put$1,
    get: get$1,
    all: all$1,
    first: first$1,
    update: update$1,
    "delete": _delete$1,
    where: where$1,
    subscribe: subscribe$1,
    overload: overload$1,
    load: load$1
  };
}

config$1.put = put$1;
config$1.get = get$1;
config$1.all = all$1;
config$1.first = first$1;
config$1.update = update$1;
config$1["delete"] = _delete$1;
config$1.where = where$1;
config$1.subscribe = subscribe$1;
config$1.overload = overload$1;
config$1.load = load$1;

var noop$1 = function noop(v) {
  return v;
};

function overload$1() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$1;
  return new Promise( /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {
      var oldConfig, result;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return all$1();

            case 2:
              oldConfig = _context.sent;
              _context.prev = 3;
              config$1(opts);
              _context.t0 = callback;
              _context.next = 8;
              return all$1();

            case 8:
              _context.t1 = _context.sent;
              _context.next = 11;
              return (0, _context.t0)(_context.t1);

            case 11:
              result = _context.sent;
              _context.next = 14;
              return resetConfig$1(oldConfig);

            case 14:
              resolve(result);
              _context.next = 22;
              break;

            case 17:
              _context.prev = 17;
              _context.t2 = _context["catch"](3);
              _context.next = 21;
              return resetConfig$1(oldConfig);

            case 21:
              reject(_context.t2);

            case 22:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 17]]);
    }));

    return function (_x2, _x3) {
      return _ref6.apply(this, arguments);
    };
  }());
}

/**
 * The levels of the logger
 * 
 * @typedef {Object} LEVELS
 * @property {number} debug - The debug level
 * @property {number} info - The info level
 * @property {number} log - The log level
 * @property {number} warn - The warn level
 * @property {number} error - The error level
 * 
 */

var LEVELS = Object.freeze({
  debug: 5,
  info: 4,
  log: 3,
  warn: 2,
  error: 1
});
/**
 * Builds a message formatted for the logger
 * 
 * @param {Object} options - The options for the log
 * @param {string} options.title - The title of the log
 * @param {string} options.message - The message of the log
 * @returns {Array<string>} - The message formatted for the logger
 * 
 * @example
 * buildLoggerMessageArgs({ title: "My Title", message: "My Message" })
 */

var buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {
  var title = _ref.title,
      message = _ref.message;
  return ["\n    %c".concat(title, "\n    ============================\n\n    ").concat(message, "\n\n    ============================\n    ").replace(/\n[^\S\r\n]+/g, "\n").trim(),, "font-weight:bold;font-family:monospace;"];
};
/**
 * Logs messages based on the level of the message and the level set in the config
 * 
 * @param {Object} options - The options for the log
 * @param {string} options.title - The title of the log
 * @param {string} options.message - The message of the log
 * @param {number} options.level - The level of the log
 * @param {boolean} options.always - Whether to always show the log
 * @returns {Promise<void>}
 * 
 * @example
 * log({ title: "My Title", message: "My Message", level: LEVELS.warn, always: false })
 * 
 */


var log = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {
    var _console, _console2, _console3, _console4, _console5;

    var title, message, level, _ref2$always, always, configLoggerLevel, loggerMessageArgs;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            title = _ref2.title, message = _ref2.message, level = _ref2.level, _ref2$always = _ref2.always, always = _ref2$always === void 0 ? false : _ref2$always;
            _context.next = 3;
            return config$1.get("logger.level", LEVELS.warn);

          case 3:
            configLoggerLevel = _context.sent;

            if (!(!always && configLoggerLevel < level)) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return");

          case 6:
            loggerMessageArgs = buildLoggerMessageArgs({
              title: title,
              message: message
            });
            _context.t0 = level;
            _context.next = _context.t0 === LEVELS.debug ? 10 : _context.t0 === LEVELS.info ? 12 : _context.t0 === LEVELS.warn ? 14 : _context.t0 === LEVELS.error ? 16 : 18;
            break;

          case 10:
            (_console = console).debug.apply(_console, _toConsumableArray(loggerMessageArgs));

            return _context.abrupt("break", 19);

          case 12:
            (_console2 = console).info.apply(_console2, _toConsumableArray(loggerMessageArgs));

            return _context.abrupt("break", 19);

          case 14:
            (_console3 = console).warn.apply(_console3, _toConsumableArray(loggerMessageArgs));

            return _context.abrupt("break", 19);

          case 16:
            (_console4 = console).error.apply(_console4, _toConsumableArray(loggerMessageArgs));

            return _context.abrupt("break", 19);

          case 18:
            (_console5 = console).log.apply(_console5, _toConsumableArray(loggerMessageArgs));

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function log(_x) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Logs a deprecation notice
 * 
 * @param {Object} options - The options for the log
 * @param {string} options.pkg - The package that is being deprecated
 * @param {string} options.subject - The subject of the deprecation
 * @param {string} options.transition - The transition path for the deprecation
 * @param {number} options.level - The level of the log
 * @param {string} options.message - The message of the log
 * @param {Function} options.callback - A callback to run after the log
 * @returns {Promise<void>}
 * 
 * @example
 * log.deprecate({ pkg: "@onflow/fcl", subject: "Some item", transition: "https://github.com/onflow/flow-js-sdk", message: "Descriptive message", level: LEVELS.warn, callback: () => {} })
 * 
 */


log.deprecate = function (_ref4) {
  var pkg = _ref4.pkg,
      subject = _ref4.subject,
      transition = _ref4.transition,
      _ref4$level = _ref4.level,
      level = _ref4$level === void 0 ? LEVELS.warn : _ref4$level,
      _ref4$message = _ref4.message,
      message = _ref4$message === void 0 ? "" : _ref4$message,
      _ref4$callback = _ref4.callback,
      callback = _ref4$callback === void 0 ? null : _ref4$callback;

  var capitalizeFirstLetter = function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };

  var logMessage = function logMessage() {
    return log({
      title: "".concat(pkg ? pkg + " " : "", "Deprecation Notice"),
      message: "\n      ".concat(subject ? "".concat(capitalizeFirstLetter(subject), " is deprecated and will cease to work in future releases").concat(pkg ? " of " + pkg : "", ".") : "").concat(message ? "\n" + message : "").concat(transition ? "\nYou can learn more (including a guide on common transition paths) here: ".concat(transition) : "", "\n    ").trim(),
      level: level
    });
  };

  if (typeof callback === "function") {
    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var _args2 = arguments;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return logMessage();

            case 2:
              _context2.next = 4;
              return callback.apply(void 0, _args2);

            case 4:
              return _context2.abrupt("return", _context2.sent);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  }

  return logMessage();
};

/**
 * Asserts fact is true, otherwise throw an error with invariant message
 * @param {boolean} fact
 * @param {string} msg
 * @param {Array} rest
 * @returns {void}
 */
function invariant(fact, msg) {
  if (!fact) {
    var _console;

    var error = new Error("INVARIANT ".concat(msg));
    error.stack = error.stack.split("\n").filter(function (d) {
      return !/at invariant/.test(d);
    }).join("\n");

    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }

    (_console = console).error.apply(_console, ["\n\n---\n\n", error, "\n\n"].concat(rest, ["\n\n---\n\n"]));

    throw error;
  }
}

var pipe = function pipe() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function (v) {
    return funcs.reduce(function (res, func) {
      return func(res);
    }, v);
  };
};
/***
 * Merge multiple functions returning objects into one object.
 * @param {...function(*): Object} funcs
 * @return {Object}
 */


var mergePipe = function mergePipe() {
  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    funcs[_key2] = arguments[_key2];
  }

  return function (v) {
    return funcs.reduce(function (res, func) {
      return _objectSpread(_objectSpread({}, res), func(v));
    }, {});
  };
};
/**
 * Object check.
 * @param value
 * @returns {boolean}
 */


var isObject = function isObject(value) {
  return value && _typeof(value) === "object" && !Array.isArray(value);
};
/**
 * Deep merge multiple objects.
 * @param {Object} target
 * @param {...Object[]} sources
 * @returns {Object}
 */


var mergeDeep = function mergeDeep(target) {
  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    sources[_key3 - 1] = arguments[_key3];
  }

  if (!sources.length) return target;
  var source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (var key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, _defineProperty({}, key, source[key]));
      }
    }
  }

  return mergeDeep.apply(void 0, [target].concat(sources));
};
/**
 * Deep merge multiple Flow JSON.
 * @param {Object|Object[]} value
 * @returns {Object}
 */

var mergeFlowJSONs = function mergeFlowJSONs(value) {
  return Array.isArray(value) ? mergeDeep.apply(void 0, [{}].concat(_toConsumableArray(value))) : value;
};
/**
 * Filter out contracts section of flow.json.
 * @param {Object|Object[]} obj
 * @returns {Object}
 */


var filterContracts = function filterContracts(obj) {
  return obj.contracts ? obj.contracts : {};
};
/**
 * Gathers contract addresses by network
 * @param {string} network emulator, testnet, mainnet
 * @returns {Object} { "HelloWorld": "0x123" }
 */


var mapContractAliasesToNetworkAddress = function mapContractAliasesToNetworkAddress(network) {
  return function (contracts) {
    return Object.entries(contracts).reduce(function (c, _ref) {
      var _value$aliases;

      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      var networkContractAlias = value === null || value === void 0 ? void 0 : (_value$aliases = value.aliases) === null || _value$aliases === void 0 ? void 0 : _value$aliases[network];

      if (networkContractAlias) {
        c[key] = networkContractAlias;
      }

      return c;
    }, {});
  };
};

var mapDeploymentsToNetworkAddress = function mapDeploymentsToNetworkAddress(network) {
  return function (_ref3) {
    var _ref3$deployments = _ref3.deployments,
        deployments = _ref3$deployments === void 0 ? {} : _ref3$deployments,
        _ref3$accounts = _ref3.accounts,
        accounts = _ref3$accounts === void 0 ? {} : _ref3$accounts;
    var networkDeployment = deployments === null || deployments === void 0 ? void 0 : deployments[network];
    if (!networkDeployment) return {};
    return Object.entries(networkDeployment).reduce(function (c, _ref4) {
      var _accounts$key;

      var _ref5 = _slicedToArray(_ref4, 2),
          key = _ref5[0],
          value = _ref5[1];

      // Resolve account address
      var accountAddress = (_accounts$key = accounts[key]) === null || _accounts$key === void 0 ? void 0 : _accounts$key.address;
      if (!accountAddress) return c; // Create an object assigning the address to the contract name.

      return value.reduce(function (c, contract) {
        return _objectSpread(_objectSpread({}, c), {}, _defineProperty({}, contract, accountAddress));
      }, {});
    }, {});
  };
};
/**
 * Take in flow.json files and return contract to address mapping by network
 * @param {Object|Object[]} jsons
 * @param {string} network emulator, testnet, mainnet
 * @returns {Object} { "HelloWorld": "0x123" }
 */


var getContracts = function getContracts(jsons, network) {
  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);
};
/**
 * Checks flow.json file for private keys
 * @param {Object} flowJSON
 * @returns {boolean}
 */

var hasPrivateKeys = function hasPrivateKeys(flowJSON) {
  return Object.entries(flowJSON === null || flowJSON === void 0 ? void 0 : flowJSON.accounts).reduce(function (hasPrivateKey, _ref6) {
    var _value$key;

    var _ref7 = _slicedToArray(_ref6, 2);
        _ref7[0];
        var value = _ref7[1];

    if (hasPrivateKey) return true;
    return (value === null || value === void 0 ? void 0 : value.hasOwnProperty("key")) && !(value !== null && value !== void 0 && (_value$key = value.key) !== null && _value$key !== void 0 && _value$key.startsWith("$"));
  }, false);
};
/**
 * Take in flow.json or array of flow.json files and checks for private keys
 * @param {Object|Object[]} value
 * @returns {boolean}
 */


var anyHasPrivateKeys = function anyHasPrivateKeys(value) {
  if (isObject(value)) return hasPrivateKeys(value);
  return value.some(hasPrivateKeys);
};
/**
 * Format network to always be 'emulator', 'testnet', or 'mainnet'
 * @param {string} network 'local', 'emulator', 'testnet', 'mainnet'
 * @returns {string} 'emulator', 'testnet', 'mainnet'
 */

var cleanNetwork = function cleanNetwork(network) {
  return (network === null || network === void 0 ? void 0 : network.toLowerCase()) === "local" ? "emulator" : network === null || network === void 0 ? void 0 : network.toLowerCase();
};

var _HANDLERS;
var NAME = "config";
var PUT = "PUT_CONFIG";
var GET = "GET_CONFIG";
var GET_ALL = "GET_ALL_CONFIG";
var UPDATE = "UPDATE_CONFIG";
var DELETE = "DELETE_CONFIG";
var CLEAR = "CLEAR_CONFIG";
var WHERE = "WHERE_CONFIG";
var UPDATED = "CONFIG/UPDATED";

var identity = function identity(v) {
  return v;
};

var HANDLERS = (_HANDLERS = {}, _defineProperty(_HANDLERS, PUT, function (ctx, _letter, _ref) {
  var key = _ref.key,
      value = _ref.value;
  if (key == null) throw new Error("Missing 'key' for config/put.");
  ctx.put(key, value);
  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS, GET, function (ctx, letter, _ref2) {
  var key = _ref2.key,
      fallback = _ref2.fallback;
  if (key == null) throw new Error("Missing 'key' for config/get");
  letter.reply(ctx.get(key, fallback));
}), _defineProperty(_HANDLERS, GET_ALL, function (ctx, letter) {
  letter.reply(_objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS, UPDATE, function (ctx, letter, _ref3) {
  var key = _ref3.key,
      fn = _ref3.fn;
  if (key == null) throw new Error("Missing 'key' for config/update");
  ctx.update(key, fn || identity);
  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS, DELETE, function (ctx, letter, _ref4) {
  var key = _ref4.key;
  if (key == null) throw new Error("Missing 'key' for config/delete");
  ctx["delete"](key);
  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS, CLEAR, function (ctx, letter) {
  var keys = Object.keys(ctx.all());

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    ctx["delete"](key);
  }

  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS, WHERE, function (ctx, letter, _ref5) {
  var pattern = _ref5.pattern;
  if (pattern == null) throw new Error("Missing 'pattern' for config/where");
  letter.reply(ctx.where(pattern));
}), _defineProperty(_HANDLERS, SUBSCRIBE, function (ctx, letter) {
  ctx.subscribe(letter.from);
  ctx.send(letter.from, UPDATED, _objectSpread({}, ctx.all()));
}), _defineProperty(_HANDLERS, UNSUBSCRIBE, function (ctx, letter) {
  ctx.unsubscribe(letter.from);
}), _HANDLERS);
spawn(HANDLERS, NAME);

function put(key, value) {
  send(NAME, PUT, {
    key: key,
    value: value
  });
  return config();
}

function get(key, fallback) {
  return send(NAME, GET, {
    key: key,
    fallback: fallback
  }, {
    expectReply: true,
    timeout: 10
  });
}

function first() {
  return _first.apply(this, arguments);
}

function _first() {
  _first = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var wants,
        fallback,
        _wants,
        head,
        rest,
        ret,
        _args2 = arguments;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            wants = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [];
            fallback = _args2.length > 1 ? _args2[1] : undefined;

            if (wants.length) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", fallback);

          case 4:
            _wants = _toArray(wants), head = _wants[0], rest = _wants.slice(1);
            _context2.next = 7;
            return get(head);

          case 7:
            ret = _context2.sent;

            if (!(ret == null)) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt("return", first(rest, fallback));

          case 10:
            return _context2.abrupt("return", ret);

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _first.apply(this, arguments);
}

function all() {
  return send(NAME, GET_ALL, null, {
    expectReply: true,
    timeout: 10
  });
}

function update(key) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  send(NAME, UPDATE, {
    key: key,
    fn: fn
  });
  return config();
}

function _delete(key) {
  send(NAME, DELETE, {
    key: key
  });
  return config();
}

function where(pattern) {
  return send(NAME, WHERE, {
    pattern: pattern
  }, {
    expectReply: true,
    timeout: 10
  });
}

function subscribe(callback) {
  return subscriber(NAME, function () {
    return spawn(HANDLERS, NAME);
  }, callback);
}

function clearConfig() {
  return send(NAME, CLEAR);
}

function resetConfig(oldConfig) {
  return clearConfig().then(config(oldConfig));
}
/**
 * Takes in flow.json or array of flow.json files and creates contract placeholders
 * @param {Object|Object[]} data
 * @returns {void}
 */


function load(_x) {
  return _load.apply(this, arguments);
}
/**
 * Takes an object of config keys and returns an object with config methods
 *
 * @param {Object} values
 * @returns {Object} config
 * @returns {Function} config.put
 * @returns {Function} config.get
 * @returns {Function} config.all
 * @returns {Function} config.first
 * @returns {Function} config.update
 * @returns {Function} config.delete
 * @returns {Function} config.where
 * @returns {Function} config.subscribe
 * @returns {Function} config.overload
 * @returns {Function} config.load
 *
 * @example
 * import {config} from "@onflow/fcl"
 * config({ "flow.network": "testnet" })
 *
 */


function _load() {
  _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(data) {
    var network, cleanedNetwork, flowJSON, isEmulator, _i2, _Object$entries, _Object$entries$_i, key, value, contractConfigKey, existingContractConfigKey, systemContractConfigKey, systemExistingContractConfigKeyValue;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return get("flow.network");

          case 2:
            network = _context3.sent;
            cleanedNetwork = cleanNetwork(network);
            flowJSON = data.flowJSON;
            invariant(Boolean(flowJSON), "config.load -- 'flowJSON' must be defined");
            invariant(cleanedNetwork, "Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl");

            if (!anyHasPrivateKeys(flowJSON)) {
              _context3.next = 12;
              break;
            }

            isEmulator = cleanedNetwork === "emulator";
            log({
              title: "Private Keys Detected",
              message: "Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security",
              level: isEmulator ? LEVELS.warn : LEVELS.error
            });

            if (isEmulator) {
              _context3.next = 12;
              break;
            }

            return _context3.abrupt("return");

          case 12:
            _i2 = 0, _Object$entries = Object.entries(getContracts(flowJSON, cleanedNetwork));

          case 13:
            if (!(_i2 < _Object$entries.length)) {
              _context3.next = 28;
              break;
            }

            _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
            contractConfigKey = "0x".concat(key);
            _context3.next = 18;
            return get(contractConfigKey);

          case 18:
            existingContractConfigKey = _context3.sent;

            if (existingContractConfigKey && existingContractConfigKey !== value) {
              log({
                title: "Contract Placeholder Conflict Detected",
                message: "A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.",
                level: LEVELS.warn
              });
            } else {
              put(contractConfigKey, value);
            }

            systemContractConfigKey = "system.contracts.".concat(key);
            _context3.next = 23;
            return get(systemContractConfigKey);

          case 23:
            systemExistingContractConfigKeyValue = _context3.sent;

            if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {
              log({
                title: "Contract Placeholder Conflict Detected",
                message: "A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.",
                level: LEVELS.warn
              });
            } else {
              put(systemContractConfigKey, value);
            }

          case 25:
            _i2++;
            _context3.next = 13;
            break;

          case 28:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _load.apply(this, arguments);
}

function config(values) {
  if (values != null && _typeof(values) === "object") {
    Object.keys(values).map(function (d) {
      return put(d, values[d]);
    });
  }

  return {
    put: put,
    get: get,
    all: all,
    first: first,
    update: update,
    "delete": _delete,
    where: where,
    subscribe: subscribe,
    overload: overload,
    load: load
  };
}

config.put = put;
config.get = get;
config.all = all;
config.first = first;
config.update = update;
config["delete"] = _delete;
config.where = where;
config.subscribe = subscribe;
config.overload = overload;
config.load = load;

var noop = function noop(v) {
  return v;
};

function overload() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
  return new Promise( /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {
      var oldConfig, result;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return all();

            case 2:
              oldConfig = _context.sent;
              _context.prev = 3;
              config(opts);
              _context.t0 = callback;
              _context.next = 8;
              return all();

            case 8:
              _context.t1 = _context.sent;
              _context.next = 11;
              return (0, _context.t0)(_context.t1);

            case 11:
              result = _context.sent;
              _context.next = 14;
              return resetConfig(oldConfig);

            case 14:
              resolve(result);
              _context.next = 22;
              break;

            case 17:
              _context.prev = 17;
              _context.t2 = _context["catch"](3);
              _context.next = 21;
              return resetConfig(oldConfig);

            case 21:
              reject(_context.t2);

            case 22:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 17]]);
    }));

    return function (_x2, _x3) {
      return _ref6.apply(this, arguments);
    };
  }());
}

export { clearConfig, config };
//# sourceMappingURL=config.module.js.map
